Task
Given an integer, n, perform the following conditional actions:
If  n is odd, print Weird
If  n is even and in the inclusive range of  2 to 5, print Not Weird
If  n is even and in the inclusive range of  6 to 20 , print Weird
If  n is even and greater than , print Not Weird 



-------
C O D E
-------



#!/bin/python3

import math
import os
import random
import re
import sys

if __name__ == '__main__':
    n = int(input().strip())   
if n % 2 != 0 :
    print("Weird")                        # Odd Number
elif n % 2 == 0 and 2 <= n <=5 :
    print("Not Weird")                    # Even and between 2 to 5 (inclusive)
elif n % 2 == 0 and 6 <= n <= 20 :
    print("Weird")                        # Even and between 6 to 20 (inclusive)
elif n % 2 == 0 and n > 20 :
    print("Not Weird")                    # Even and greater than 20



1. Problem Restatement

An integer n is given as input.
Based on whether n is odd or even, and which numerical range it belongs to, a specific string must be printed:

* Odd → Weird
* Even & between 2–5 → Not Weird
* Even & between 6–20 → Weird
* Even & greater than 20 → Not Weird



2. Core Idea / Insight

The problem is not about math — it’s about (decision ordering).

Key insight:

* (Odd/even check dominates everything else)
* For even numbers, (range-based conditions) decide the output
* Conditions must be (mutually exclusive) and checked in the correct order

If conditions overlap or are misordered, the logic breaks.



3. Step-by-Step Logic (Without Code)

1. Read the integer n.
2. Check if n is odd.
   * If yes, print Weird and stop.
3. If n is even:
   * If n is between 2 and 5, print Not Weird.
   * Else if n is between 6 and 20, print Weird.
   * Else (greater than 20), print Not Weird.

Each number satisfies (exactly one) condition.



4. Code Walkthrough (Logic → Implementation)

n = int(input().strip())
* Reads input and removes any extra whitespace.
* Converts input to integer for numeric comparisons.

if n % 2 != 0:
* (% 2 != 0) checks if n is odd.
* Odd numbers immediately print "Weird".

elif n % 2 == 0 and 2 <= n <= 5:
* Confirms number is even **and** within the lower range.
* Prints "Not Weird".

elif n % 2 == 0 and 6 <= n <= 20:
* Even number within mid-range.
* Prints "Weird".

elif n % 2 == 0 and n > 20:
* Even number above the range.
* Prints "Not Weird".



Important Code Issue (We Can’t Ignore This)

Our indentation is (wrong).

if __name__ == '__main__':
    n = int(input().strip())   
if n % 2 != 0 :

The condition checks are (outside) the if __name__ == '__main__': block.
This will still run in some environments, but it’s (bad practice) and can break modular code.

Correct Structure (Minimal Fix)

if __name__ == '__main__':
    n = int(input().strip())

    if n % 2 != 0:
        print("Weird")
    elif 2 <= n <= 5:
        print("Not Weird")
    elif 6 <= n <= 20:
        print("Weird")
    elif n % 2 == 0 and n > 20:
        print("Not Weird")

Notice:

* No repeated n % 2 == 0 checks
* Cleaner and safer logic



5. Time & Space Complexity

* Time Complexity: O(1)
  Only constant-time comparisons.
* Space Complexity: O(1)
  One integer variable.



6. Why This Solution Is Optimal

* All conditions are evaluated once.
* Uses direct comparisons instead of nested logic.
* Eliminates redundancy.
* Matches the problem rules exactly.

There is (no faster or simpler) approach.



7. Common Mistakes & Traps

* Repeating n % 2 == 0 unnecessarily
* Wrong indentation
* Misordering conditions (checking range before odd/even)
* Forgetting inclusive bounds (<=, >=)
* Using separate if instead of elif (causes multiple prints)



8. Trade-offs & Alternatives

* A dictionary-based solution is possible but reduces clarity.
* Nested if blocks work but are harder to read.
* This linear if–elif–else chain is the (cleanest and safest).



9. Pattern Recognition (Meta-Learning)

This is a classic (rule-based classification) pattern:

* Check dominant condition first
* Narrow down with ranges
* Ensure exclusivity

We’ll see this pattern again in:

* Input validation
* Business rules
* State machines
* Interview decision-tree problems



Bring the next one.

